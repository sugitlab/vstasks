// Generated by Copilot
import {
  ITask,
  TaskStatus,
  Priority,
  IRecurrenceRule,
  RecurrenceType,
} from "./task";
import * as vscode from "vscode";
import { v4 as uuidv4 } from "uuid";

/**
 * Class responsible for parsing markdown content and extracting tasks.
 */
export class TaskParser {
  /**
   * Regular expression to match task items in markdown.
   * Matches both - [ ] and - [x] formats.
   */
  private static readonly TASK_REGEX = /^(\s*)[-*+]\s+\[([ xX])\]\s+(.+)$/;

  /**
   * Regular expression to match due date in task description.
   * Format: ğŸ“… YYYY-MM-DD
   */
  private static readonly DUE_DATE_REGEX = /ğŸ“…\s*(\d{4}-\d{2}-\d{2})/;

  /**
   * Regular expression to match scheduled date in task description.
   * Format: â³ YYYY-MM-DD
   */
  private static readonly SCHEDULED_DATE_REGEX = /â³\s*(\d{4}-\d{2}-\d{2})/;

  /**
   * Regular expression to match completed date in task description.
   * Format: âœ… YYYY-MM-DD
   */
  private static readonly COMPLETED_DATE_REGEX = /âœ…\s*(\d{4}-\d{2}-\d{2})/;

  /**
   * Regular expression to match priority markers.
   * â« = highest, â¬†ï¸ = high, ğŸ”¼ = medium, ğŸ”½ = low
   */
  private static readonly PRIORITY_REGEX = /(â«|â¬†ï¸|ğŸ”¼|ğŸ”½)/;

  /**
   * Regular expression to match tags.
   * Format: #tag
   */
  private static readonly TAG_REGEX = /#([a-zA-Z0-9_-]+)/g;

  /**
   * Regular expression to match recurrence rules.
   * Format: ğŸ” every day/week/month/year
   */
  private static readonly RECURRENCE_REGEX =
    /ğŸ”\s+(every\s+(\d+)?\s*(day|week|month|year)s?)/i;

  /**
   * Parse markdown content and extract tasks.
   *
   * @param content The markdown content to parse
   * @param filePath The path to the file being parsed
   * @returns Array of parsed tasks
   */
  public parseMarkdownContent(content: string, filePath: string): ITask[] {
    const lines = content.split("\n");
    const tasks: ITask[] = [];

    for (let i = 0; i < lines.length; i++) {
      const task = this.parseLine(lines[i], i, filePath);
      if (task) {
        tasks.push(task);
      }
    }

    return tasks;
  }

  /**
   * Parse a single line and extract a task if present.
   *
   * @param line The line to parse
   * @param lineNumber The line number in the file
   * @param filePath The path to the file being parsed
   * @returns A task object if the line contains a task, null otherwise
   */
  public parseLine(
    line: string,
    lineNumber: number,
    filePath: string
  ): ITask | null {
    const match = TaskParser.TASK_REGEX.exec(line);
    if (!match) {
      return null;
    }

    const status = match[2] === " " ? TaskStatus.TODO : TaskStatus.DONE;
    const description = match[3];

    const task: ITask = {
      id: uuidv4(),
      description: description,
      status,
      filePath,
      lineNumber,
      rawText: line,
      ...this.extractDates(description),
      priority: this.extractPriority(description),
      tags: this.extractTags(description),
      recurrence: this.extractRecurrence(description),
    };

    return task;
  }

  /**
   * Extract dates from task description.
   *
   * @param text The task description
   * @returns Object containing due, scheduled, and completed dates
   */
  public extractDates(text: string): {
    dueDate?: Date;
    scheduledDate?: Date;
    completedDate?: Date;
  } {
    const result: {
      dueDate?: Date;
      scheduledDate?: Date;
      completedDate?: Date;
    } = {};

    // Extract due date
    const dueMatch = TaskParser.DUE_DATE_REGEX.exec(text);
    if (dueMatch) {
      result.dueDate = new Date(dueMatch[1]);
    }

    // Extract scheduled date
    const scheduledMatch = TaskParser.SCHEDULED_DATE_REGEX.exec(text);
    if (scheduledMatch) {
      result.scheduledDate = new Date(scheduledMatch[1]);
    }

    // Extract completed date
    const completedMatch = TaskParser.COMPLETED_DATE_REGEX.exec(text);
    if (completedMatch) {
      result.completedDate = new Date(completedMatch[1]);
    }

    return result;
  }

  /**
   * Extract priority from task description.
   *
   * @param text The task description
   * @returns The priority level
   */
  public extractPriority(text: string): Priority {
    const priorityMatch = TaskParser.PRIORITY_REGEX.exec(text);
    if (!priorityMatch) {
      return Priority.NONE;
    }

    switch (priorityMatch[1]) {
      case "â«":
        return Priority.HIGHEST;
      case "â¬†ï¸":
        return Priority.HIGH;
      case "ğŸ”¼":
        return Priority.MEDIUM;
      case "ğŸ”½":
        return Priority.LOW;
      default:
        return Priority.NONE;
    }
  }

  /**
   * Extract tags from task description.
   *
   * @param text The task description
   * @returns Array of tags
   */
  public extractTags(text: string): string[] {
    const tags: string[] = [];
    let match;

    // Reset regex lastIndex to ensure we start from the beginning
    TaskParser.TAG_REGEX.lastIndex = 0;

    while ((match = TaskParser.TAG_REGEX.exec(text)) !== null) {
      tags.push(match[1]);
    }

    return tags;
  }

  /**
   * Extract recurrence rule from task description.
   *
   * @param text The task description
   * @returns Recurrence rule object or null if no recurrence
   */
  public extractRecurrence(text: string): IRecurrenceRule | undefined {
    const recurrenceMatch = TaskParser.RECURRENCE_REGEX.exec(text);
    if (!recurrenceMatch) {
      return undefined;
    }

    const interval = recurrenceMatch[2] ? parseInt(recurrenceMatch[2]) : 1;
    let type: RecurrenceType;

    switch (recurrenceMatch[3].toLowerCase()) {
      case "day":
        type = RecurrenceType.DAILY;
        break;
      case "week":
        type = RecurrenceType.WEEKLY;
        break;
      case "month":
        type = RecurrenceType.MONTHLY;
        break;
      case "year":
        type = RecurrenceType.YEARLY;
        break;
      default:
        type = RecurrenceType.CUSTOM;
        break;
    }

    return {
      type,
      interval,
    };
  }
}
