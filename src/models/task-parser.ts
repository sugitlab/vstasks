// Generated by Copilot
import {
  ITask,
  TaskStatus,
  Priority,
  IRecurrenceRule,
  RecurrenceType,
} from "./task";
import { v4 as uuidv4 } from "uuid";

/**
 * Class responsible for parsing markdown content and extracting tasks.
 */
export class TaskParser {
  /**
   * Regular expression to match task items in markdown.
   * Matches both - [ ] and - [x] formats.
   */
  private static readonly TASK_REGEX = /^(\s*)[-*+]\s+\[([ xX])\]\s+(.+)$/;

  /**
   * Regular expression to match due date in task description.
   * Format: ğŸ“… YYYY-MM-DD
   */
  private static readonly DUE_DATE_REGEX = /ğŸ“…\s*(\d{4}-\d{2}-\d{2})/;

  /**
   * Regular expression to match scheduled date in task description.
   * Format: â³ YYYY-MM-DD
   */
  private static readonly SCHEDULED_DATE_REGEX = /â³\s*(\d{4}-\d{2}-\d{2})/;

  /**
   * Regular expression to match completed date in task description.
   * Format: âœ… YYYY-MM-DD
   */
  private static readonly COMPLETED_DATE_REGEX = /âœ…\s*(\d{4}-\d{2}-\d{2})/;

  /**
   * Regular expression to match priority markers.
   * 4ï¸âƒ£ = highest, 3ï¸âƒ£ = high, 2ï¸âƒ£ = medium, 1ï¸âƒ£ = low
   */
  private static readonly PRIORITY_REGEX = /(1ï¸âƒ£|2ï¸âƒ£|3ï¸âƒ£|4ï¸âƒ£)/;

  /**
   * Regular expression to match tags.
   * Format: #tag
   */
  private static readonly TAG_REGEX = /#([a-zA-Z0-9_-]+)/g;

  /**
   * Regular expression to match recurrence rules.
   * Format: ğŸ” every day/week/month/year
   */
  private static readonly RECURRENCE_REGEX =
    /ğŸ”\s+(every\s+(\d+)?\s*(day|week|month|year)s?)/i;

  /**
   * Parse markdown content and extract tasks.
   *
   * @param content The markdown content to parse
   * @param filePath The path to the file being parsed
   * @returns Array of parsed tasks
   */
  public parseMarkdownContent(content: string, filePath: string): ITask[] {
    const lines = content.split("\n");
    const tasks: ITask[] = [];

    for (let i = 0; i < lines.length; i++) {
      const task = this.parseLine(lines[i], i, filePath);
      if (task) {
        tasks.push(task);
      }
    }

    return tasks;
  }

  /**
   * Parse a single line and extract a task if present.
   *
   * @param line The line to parse
   * @param lineNumber The line number in the file
   * @param filePath The path to the file being parsed
   * @returns A task object if the line contains a task, null otherwise
   */
  public parseLine(
    line: string,
    lineNumber: number,
    filePath: string
  ): ITask | null {
    const match = TaskParser.TASK_REGEX.exec(line);
    if (!match) {
      return null;
    }

    const status = match[2] === " " ? TaskStatus.TODO : TaskStatus.DONE;
    const description = match[3];

    const task: ITask = {
      id: uuidv4(),
      description: description,
      status,
      filePath,
      lineNumber,
      rawText: line,
      ...this.extractDates(description),
      priority: this.extractPriority(description),
      tags: this.extractTags(description),
      recurrence: this.extractRecurrence(description),
    };

    return task;
  }

  /**
   * Extract dates from task description.
   *
   * @param text The task description
   * @returns Object containing due, scheduled, and completed dates
   */
  public extractDates(text: string): {
    dueDate?: Date;
    scheduledDate?: Date;
    completedDate?: Date;
  } {
    const result: {
      dueDate?: Date;
      scheduledDate?: Date;
      completedDate?: Date;
    } = {};

    // Extract due date
    const dueMatch = TaskParser.DUE_DATE_REGEX.exec(text);
    if (dueMatch) {
      result.dueDate = new Date(dueMatch[1]);
    }

    // Extract scheduled date
    const scheduledMatch = TaskParser.SCHEDULED_DATE_REGEX.exec(text);
    if (scheduledMatch) {
      result.scheduledDate = new Date(scheduledMatch[1]);
    }

    // Extract completed date
    const completedMatch = TaskParser.COMPLETED_DATE_REGEX.exec(text);
    if (completedMatch) {
      result.completedDate = new Date(completedMatch[1]);
    }

    return result;
  }

  /**
   * Extract priority from task description.
   *
   * @param text The task description
   * @returns The priority level
   * @generated Generated by Copilot
   */
  public extractPriority(text: string): Priority {
    // Always reset lastIndex in case regex is reused
    // Now match 1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ (keycap emoji)
    const match = /(1ï¸âƒ£|2ï¸âƒ£|3ï¸âƒ£|4ï¸âƒ£)/.exec(text);
    if (!match) {
      return Priority.NONE;
    }
    switch (match[1]) {
      case "1ï¸âƒ£":
        return Priority.LOW;
      case "2ï¸âƒ£":
        return Priority.MEDIUM;
      case "3ï¸âƒ£":
        return Priority.HIGH;
      case "4ï¸âƒ£":
        return Priority.HIGHEST;
      default:
        return Priority.NONE;
    }
  }

  /**
   * Extract tags from task description.
   *
   * @param text The task description
   * @returns Array of tags (without # prefix, for compatibility with tests)
   * @generated Generated by Copilot
   */
  public extractTags(text: string): string[] {
    const tags: string[] = [];
    let match;
    // Use a global regex to match all #tags (must start with # and at least one letter)
    const regex = /(^|\s)#([a-zA-Z][a-zA-Z0-9_-]*)/g;
    while ((match = regex.exec(text)) !== null) {
      tags.push(match[2]);
    }
    return tags;
  }

  /**
   * Extract recurrence rule from task description.
   *
   * @param text The task description
   * @returns Recurrence rule object or null if no recurrence
   */
  public extractRecurrence(text: string): IRecurrenceRule | undefined {
    const recurrenceMatch = TaskParser.RECURRENCE_REGEX.exec(text);
    if (!recurrenceMatch) {
      return undefined;
    }

    const interval = recurrenceMatch[2] ? parseInt(recurrenceMatch[2]) : 1;
    let type: RecurrenceType;

    switch (recurrenceMatch[3].toLowerCase()) {
      case "day":
        type = RecurrenceType.DAILY;
        break;
      case "week":
        type = RecurrenceType.WEEKLY;
        break;
      case "month":
        type = RecurrenceType.MONTHLY;
        break;
      case "year":
        type = RecurrenceType.YEARLY;
        break;
      default:
        type = RecurrenceType.CUSTOM;
        break;
    }

    return {
      type,
      interval,
    };
  }

  /**
   * ITaskã‹ã‚‰ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³è¡Œã‚’ç”Ÿæˆ
   * @param task ç·¨é›†å¾Œã®ã‚¿ã‚¹ã‚¯
   * @generated Generated by Copilot
   */
  public static generateTaskLine(task: ITask): string {
    // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
    const checkbox = task.status === TaskStatus.DONE ? "[x]" : "[ ]";
    // description ã‹ã‚‰æ—¢å­˜ã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è¡¨ç¾ï¼ˆpriority, dates, recurrence, completed, ã‚¿ã‚°ï¼‰ã‚’é™¤å»
    let desc = task.description
      .replace(/(1ï¸âƒ£|2ï¸âƒ£|3ï¸âƒ£|4ï¸âƒ£)/g, "")
      .replace(/ğŸ“…\s*\d{4}-\d{2}-\d{2}/g, "")
      .replace(/â³\s*\d{4}-\d{2}-\d{2}/g, "")
      .replace(/ğŸ”/g, "")
      .replace(/âœ…\s*\d{4}-\d{2}-\d{2}/g, "")
      .replace(/#[a-zA-Z0-9_-]+/g, "") // ã‚¿ã‚°ã‚‚ä¸€æ—¦å…¨ã¦é™¤å»ï¼ˆæ­£è¦è¡¨ç¾ä¿®æ­£ï¼‰
      .replace(/\s+/g, " ")
      .trim();
    // priorityï¼ˆ1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ï¼‰
    if (
      typeof task.priority !== "undefined" &&
      task.priority !== null &&
      task.priority !== 0
    ) {
      let priorityEmoji = "";
      switch (task.priority) {
        case Priority.LOW:
          priorityEmoji = "1ï¸âƒ£";
          break;
        case Priority.MEDIUM:
          priorityEmoji = "2ï¸âƒ£";
          break;
        case Priority.HIGH:
          priorityEmoji = "3ï¸âƒ£";
          break;
        case Priority.HIGHEST:
          priorityEmoji = "4ï¸âƒ£";
          break;
      }
      if (priorityEmoji) {
        desc += ` ${priorityEmoji}`;
      }
    }
    // dueDateï¼ˆğŸ“…ï¼‰
    if (task.dueDate) {
      desc += ` ğŸ“… ${
        task.dueDate instanceof Date
          ? task.dueDate.toISOString().slice(0, 10)
          : task.dueDate
      }`;
    }
    // scheduledDateï¼ˆâ³ï¼‰
    if (task.scheduledDate) {
      desc += ` â³ ${
        task.scheduledDate instanceof Date
          ? task.scheduledDate.toISOString().slice(0, 10)
          : task.scheduledDate
      }`;
    }
    // tagsï¼ˆ#tagï¼‰: å¿…ãštask.tagsã‹ã‚‰å†æ§‹ç¯‰
    if (task.tags && Array.isArray(task.tags) && task.tags.length > 0) {
      desc +=
        " " + task.tags.map((t) => (t.startsWith("#") ? t : `#${t}`)).join(" ");
    }
    // recurrenceï¼ˆğŸ”ï¼‰
    if (task.recurrence && typeof task.recurrence === "object") {
      desc += " ğŸ”";
    }
    // completedDateï¼ˆâœ…ï¼‰ã¯å¿…ãš1ã¤ã ã‘ã€statusãŒDONEã®ã¨ãã®ã¿
    if (task.completedDate && task.status === TaskStatus.DONE) {
      desc += ` âœ… ${
        task.completedDate instanceof Date
          ? task.completedDate.toISOString().slice(0, 10)
          : task.completedDate
      }`;
    }
    return `- ${checkbox} ${desc.trim()}`;
  }
}
