// Generated by Copilot
import * as vscode from "vscode";
import * as path from "path";
import { TaskManager } from "../models/task-manager";
import { TaskTreeItem } from "./task-tree-item";
import { ITask, TaskStatus } from "../models/task";

/**
 * Provider for the task tree view.
 */
export class TaskTreeDataProvider
  implements vscode.TreeDataProvider<TaskTreeItem>
{
  private _onDidChangeTreeData = new vscode.EventEmitter<
    TaskTreeItem | undefined | null | void
  >();
  readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

  constructor(private taskManager: TaskManager) {
    // Listen for task changes
    this.taskManager.onDidTasksChange(() => {
      this.refresh();
    });
  }

  /**
   * Refresh the tree view.
   */
  public refresh(): void {
    this._onDidChangeTreeData.fire();
  }

  /**
   * Get tree item for a given element.
   *
   * @param element The element
   * @returns The tree item
   */
  getTreeItem(element: TaskTreeItem): vscode.TreeItem {
    return element;
  }

  /**
   * Get children of a given element.
   *
   * @param element The parent element
   * @returns Array of child elements
   */
  getChildren(element?: TaskTreeItem): Thenable<TaskTreeItem[]> {
    if (!element) {
      // Root level - show groups
      return Promise.resolve(this.getRootItems());
    }

    if (element.type === "group") {
      // Group level - show tasks for this group
      switch (element.groupName) {
        case "By Status":
          return Promise.resolve(this.getStatusGroups());
        case "By File":
          return Promise.resolve(this.getFileGroups());
        case "By Priority":
          return Promise.resolve(this.getPriorityGroups());
        default:
          return Promise.resolve([]);
      }
    }

    if (element.type === "file") {
      // File level - show tasks for this file
      return Promise.resolve(this.getTasksForFile(element.groupName || ""));
    }

    if (element.type === "task") {
      // Task level - no children
      return Promise.resolve([]);
    }

    return Promise.resolve([]);
  }

  /**
   * Get root level items.
   *
   * @returns Array of root items
   */
  private getRootItems(): TaskTreeItem[] {
    const allTasks = this.taskManager.getAllTasks();

    if (allTasks.length === 0) {
      return [new TaskTreeItem(undefined, "group", "No Tasks")];
    }

    return [
      new TaskTreeItem(undefined, "group", "By Status"),
      new TaskTreeItem(undefined, "group", "By File"),
      new TaskTreeItem(undefined, "group", "By Priority"),
    ];
  }

  /**
   * Get status group items.
   *
   * @returns Array of status group items
   */
  private getStatusGroups(): TaskTreeItem[] {
    const allTasks = this.taskManager.getAllTasks();
    const todoTasks = allTasks.filter(
      (task) => task.status === TaskStatus.TODO
    );
    const doneTasks = allTasks.filter(
      (task) => task.status === TaskStatus.DONE
    );
    const inProgressTasks = allTasks.filter(
      (task) => task.status === TaskStatus.IN_PROGRESS
    );
    const cancelledTasks = allTasks.filter(
      (task) => task.status === TaskStatus.CANCELLED
    );

    const result: TaskTreeItem[] = [];

    if (todoTasks.length > 0) {
      const item = new TaskTreeItem(
        undefined,
        "group",
        `Todo (${todoTasks.length})`
      );
      item.iconPath = new vscode.ThemeIcon("circle-outline");
      result.push(item);
    }

    if (inProgressTasks.length > 0) {
      const item = new TaskTreeItem(
        undefined,
        "group",
        `In Progress (${inProgressTasks.length})`
      );
      item.iconPath = new vscode.ThemeIcon("play-circle");
      result.push(item);
    }

    if (doneTasks.length > 0) {
      const item = new TaskTreeItem(
        undefined,
        "group",
        `Done (${doneTasks.length})`
      );
      item.iconPath = new vscode.ThemeIcon("check");
      result.push(item);
    }

    if (cancelledTasks.length > 0) {
      const item = new TaskTreeItem(
        undefined,
        "group",
        `Cancelled (${cancelledTasks.length})`
      );
      item.iconPath = new vscode.ThemeIcon("circle-slash");
      result.push(item);
    }

    return result;
  }

  /**
   * Get file group items.
   *
   * @returns Array of file group items
   */
  private getFileGroups(): TaskTreeItem[] {
    const allTasks = this.taskManager.getAllTasks();
    const fileMap = new Map<string, ITask[]>();

    // Group tasks by file
    for (const task of allTasks) {
      const tasks = fileMap.get(task.filePath) || [];
      tasks.push(task);
      fileMap.set(task.filePath, tasks);
    }

    // Convert to tree items
    const result: TaskTreeItem[] = [];
    for (const [filePath, tasks] of fileMap.entries()) {
      const item = new TaskTreeItem(undefined, "file", filePath);
      result.push(item);
    }

    // Sort by file name
    result.sort((a, b) => {
      const aName = a.groupName ? path.basename(a.groupName) : "";
      const bName = b.groupName ? path.basename(b.groupName) : "";
      return aName.localeCompare(bName);
    });

    return result;
  }

  /**
   * Get priority group items.
   *
   * @returns Array of priority group items
   */
  private getPriorityGroups(): TaskTreeItem[] {
    // This would be implemented to group tasks by priority
    // For now just return a placeholder
    return [
      new TaskTreeItem(
        undefined,
        "group",
        "Priority grouping not implemented yet"
      ),
    ];
  }

  /**
   * Get tasks for a specific file.
   *
   * @param filePath Path to the file
   * @returns Array of task items
   */
  private getTasksForFile(filePath: string): TaskTreeItem[] {
    const tasks = this.taskManager.getTasksByFile(filePath);

    return tasks.map((task) => new TaskTreeItem(task, "task"));
  }
}
