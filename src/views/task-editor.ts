// Generated by Copilot
import * as vscode from "vscode";
import {
  ITask,
  Priority,
  RecurrenceType,
  IRecurrenceRule,
  TaskStatus,
} from "../models/task";

export class TaskQuickPickItem implements vscode.QuickPickItem {
  label: string;
  description?: string;
  detail?: string;
  task: ITask;
  constructor(task: ITask) {
    this.task = task;
    this.label = task.description;
    this.description = `Status: ${task.status}`;
    this.detail = `Due: ${
      task.dueDate ? task.dueDate.toLocaleDateString() : "æœªè¨­å®š"
    } | Priority: ${task.priority ?? "æœªè¨­å®š"} | Tags: ${(task.tags || []).join(
      ", "
    )}`;
  }
}

export class TaskInputValidator {
  static validateDescription(description: string): string | undefined {
    if (!description || description.trim().length === 0) {
      return "èª¬æ˜ã¯å¿…é ˆã§ã™";
    }
    return undefined;
  }
  static validateDate(dateStr: string): Date | undefined {
    if (!dateStr) {
      return undefined;
    }
    const d = new Date(dateStr);
    if (isNaN(d.getTime())) {
      return undefined;
    }
    return d;
  }
  static validatePriority(priorityStr: string): Priority | undefined {
    const map: Record<string, Priority> = {
      ãªã—: Priority.NONE,
      ä½: Priority.LOW,
      ä¸­: Priority.MEDIUM,
      é«˜: Priority.HIGH,
      æœ€é«˜: Priority.HIGHEST,
      "0": Priority.NONE,
      "1": Priority.LOW,
      "2": Priority.MEDIUM,
      "3": Priority.HIGH,
      "4": Priority.HIGHEST,
    };
    return map[priorityStr] ?? undefined;
  }
  static validateTags(tagsStr: string): string[] {
    if (!tagsStr) {
      return [];
    }
    return tagsStr
      .split(/[,\s]+/)
      .map((t) => t.trim())
      .filter(Boolean);
  }
}

export class QuickPickFlow {
  static async stepDescription(init?: string): Promise<string> {
    return (
      (await vscode.window.showInputBox({
        prompt: "ã‚¿ã‚¹ã‚¯ã®èª¬æ˜ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
        value: init,
        validateInput: TaskInputValidator.validateDescription,
        ignoreFocusOut: true,
      })) ?? ""
    );
  }
  static async stepDueDate(init?: Date): Promise<Date | undefined> {
    const val = await vscode.window.showInputBox({
      prompt: "æœŸæ—¥ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: 2025-05-26)",
      value: init ? init.toISOString().slice(0, 10) : "",
      ignoreFocusOut: true,
      placeHolder: "YYYY-MM-DD",
    });
    return TaskInputValidator.validateDate(val ?? "");
  }
  static async stepPriority(): Promise<Priority> {
    const items = [
      { label: "ãªã—", value: Priority.NONE },
      { label: "ä½", value: Priority.LOW },
      { label: "ä¸­", value: Priority.MEDIUM },
      { label: "é«˜", value: Priority.HIGH },
      { label: "æœ€é«˜", value: Priority.HIGHEST },
    ];
    const picked = await vscode.window.showQuickPick(items, {
      placeHolder: "å„ªå…ˆåº¦ã‚’é¸æŠã—ã¦ãã ã•ã„",
      ignoreFocusOut: true,
    });
    return picked?.value ?? Priority.NONE;
  }
  static async stepTags(): Promise<string[]> {
    const val = await vscode.window.showInputBox({
      prompt: "ã‚¿ã‚°ã‚’ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã§å…¥åŠ›ã—ã¦ãã ã•ã„",
      value: "",
      ignoreFocusOut: true,
      placeHolder: "#work, #home",
    });
    return TaskInputValidator.validateTags(val ?? "");
  }
  static async stepRecurrence(): Promise<IRecurrenceRule | undefined> {
    const recur = await vscode.window.showQuickPick(
      [
        { label: "ãªã—", value: undefined },
        { label: "æ¯æ—¥", value: { type: RecurrenceType.DAILY, interval: 1 } },
        { label: "æ¯é€±", value: { type: RecurrenceType.WEEKLY, interval: 1 } },
        { label: "æ¯æœˆ", value: { type: RecurrenceType.MONTHLY, interval: 1 } },
        { label: "æ¯å¹´", value: { type: RecurrenceType.YEARLY, interval: 1 } },
      ],
      {
        placeHolder: "ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„",
        ignoreFocusOut: true,
      }
    );
    return recur?.value;
  }
}

export class TaskEditor {
  static async showCreateDialog(): Promise<ITask | undefined> {
    const description = await QuickPickFlow.stepDescription();
    if (!description) {
      return undefined;
    }
    const dueDate = await QuickPickFlow.stepDueDate();
    const priority = await QuickPickFlow.stepPriority();
    const tags = await QuickPickFlow.stepTags();
    const recurrence = await QuickPickFlow.stepRecurrence();
    return {
      id: "", // IDã¯å¾Œã§ä»˜ä¸
      description,
      status: TaskStatus.TODO,
      filePath: "",
      lineNumber: 0,
      dueDate,
      priority,
      tags,
      recurrence,
      rawText: "",
    };
  }
  static async showEditDialog(task: ITask): Promise<ITask | undefined> {
    // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è¡¨ç¾ã‚’é™¤å»ã—ãŸã‚¿ã‚¤ãƒˆãƒ«ã®ã¿ã‚’æŠ½å‡º
    const pureTitle = TaskEditor.extractPureTitle(task.description);
    const description = await QuickPickFlow.stepDescription(pureTitle);
    if (!description) {
      return undefined;
    }
    const dueDate = await QuickPickFlow.stepDueDate(task.dueDate);
    const priority = await QuickPickFlow.stepPriority();
    const tags = await QuickPickFlow.stepTags();
    const recurrence = await QuickPickFlow.stepRecurrence();
    return {
      ...task,
      description,
      dueDate,
      priority,
      tags,
      recurrence,
    };
  }

  /**
   * descriptionã‹ã‚‰ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³è¡¨ç¾ï¼ˆâ«, â³, ğŸ“…, #, ğŸ” ãªã©ï¼‰ã‚’é™¤å»ã—ç´”ç²‹ãªã‚¿ã‚¤ãƒˆãƒ«ã®ã¿è¿”ã™
   */
  static extractPureTitle(description: string): string {
    // çµµæ–‡å­—ã‚„ã‚¿ã‚°ã€æ—¥ä»˜ã€å„ªå…ˆåº¦ã€ç¹°ã‚Šè¿”ã—ç­‰ã‚’é™¤å»
    return description
      .replace(/(ğŸ“…|â³|â«|ğŸ”)\s*[^\s#]+/g, "") // çµµæ–‡å­—+å€¤
      .replace(/#[^\s]+/g, "") // ã‚¿ã‚°
      .replace(/\s+/g, " ") // ä½™åˆ†ãªç©ºç™½
      .trim();
  }

  static async showQuickPick<T>(
    items: Array<vscode.QuickPickItem & { value: T }>,
    options: vscode.QuickPickOptions
  ): Promise<T | undefined> {
    const picked = await vscode.window.showQuickPick(items, options);
    return picked && "value" in picked
      ? (picked as { value: T }).value
      : undefined;
  }
}
