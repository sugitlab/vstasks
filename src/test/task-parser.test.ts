// Generated by Copilot
import { describe, it, expect } from "@jest/globals";
import { TaskParser } from "../models/task-parser";
import { Priority, TaskStatus } from "../models/task";

describe("TaskParser", () => {
  const parser = new TaskParser();
  const filePath = "test.md";

  it("should parse a simple TODO task", () => {
    const line = "- [ ] Buy milk";
    const task = parser.parseLine(line, 0, filePath);
    expect(task).not.toBeNull();
    expect(task?.description).toBe("Buy milk");
    expect(task?.status).toBe(TaskStatus.TODO);
  });

  it("should parse a DONE task", () => {
    const line = "- [x] Done task";
    const task = parser.parseLine(line, 1, filePath);
    expect(task).not.toBeNull();
    expect(task?.status).toBe(TaskStatus.DONE);
  });

  it("should parse a task with due and scheduled dates", () => {
    const line = "- [ ] Task 📅 2024-01-15 ⏳ 2024-01-10";
    const task = parser.parseLine(line, 2, filePath);
    expect(task?.dueDate?.toISOString()).toContain("2024-01-15");
    expect(task?.scheduledDate?.toISOString()).toContain("2024-01-10");
  });

  it("should parse a task with priority markers", () => {
    expect(parser.extractPriority("⏫ urgent")).toBe(Priority.HIGHEST);
    expect(parser.extractPriority("⬆️ high")).toBe(Priority.HIGH);
    expect(parser.extractPriority("🔼 medium")).toBe(Priority.MEDIUM);
    expect(parser.extractPriority("🔽 low")).toBe(Priority.LOW);
    expect(parser.extractPriority("no marker")).toBe(Priority.NONE);
  });

  it("should parse tags from description", () => {
    const tags = parser.extractTags("This is a #test #tag-task");
    expect(tags).toEqual(["test", "tag-task"]);
  });

  it("should parse recurrence rule", () => {
    const rec = parser.extractRecurrence("🔁 every 2 weeks");
    expect(rec).not.toBeUndefined();
    expect(rec?.interval).toBe(2);
    expect(rec?.type).toBeDefined();
  });

  it("should return null for non-task lines", () => {
    expect(parser.parseLine("This is not a task", 3, filePath)).toBeNull();
    expect(parser.parseLine("- [] broken", 4, filePath)).toBeNull();
    expect(parser.parseLine("- [z] invalid", 5, filePath)).toBeNull();
  });

  describe("parseMarkdownContent", () => {
    it("parses multiple tasks from markdown", () => {
      const content = `- [ ] Task 1\n- [x] Task 2\nNot a task\n- [ ] Task 3 #tag`;
      const tasks = parser.parseMarkdownContent(content, filePath);
      expect(tasks.length).toBe(3);
      expect(tasks[2].tags).toContain("tag");
    });
    it("handles empty content", () => {
      expect(parser.parseMarkdownContent("", filePath)).toEqual([]);
    });
  });

  describe("extractDates", () => {
    it("returns undefined for invalid dates", () => {
      const dates = parser.extractDates("📅 notadate");
      expect(dates.dueDate).toBeUndefined();
    });
    it("parses only due or only scheduled", () => {
      const due = parser.extractDates("📅 2024-12-31");
      expect(due.dueDate).toBeInstanceOf(Date);
      expect(due.scheduledDate).toBeUndefined();
      const sched = parser.extractDates("⏳ 2024-11-01");
      expect(sched.scheduledDate).toBeInstanceOf(Date);
      expect(sched.dueDate).toBeUndefined();
    });
  });

  describe("extractTags edge cases", () => {
    it("returns empty array if no tags", () => {
      expect(parser.extractTags("no tags here")).toEqual([]);
    });
    it("ignores malformed tags", () => {
      expect(parser.extractTags("# #tag #1 #_")).toContain("tag");
    });
  });

  describe("extractRecurrence edge cases", () => {
    it("returns undefined for no recurrence", () => {
      expect(parser.extractRecurrence("no repeat")).toBeUndefined();
    });
    it("parses custom recurrence", () => {
      const rec = parser.extractRecurrence("🔁 every month on the 15th");
      expect(rec?.type).toBeDefined();
    });
  });
});
// Generated by Copilot
